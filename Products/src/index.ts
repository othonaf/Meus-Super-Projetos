import  express  from "express";
import cors from "cors";
import { Request, Response } from 'express';
import { v4 as generateId } from 'uuid';
import { products } from "./data";


const app = express()
app.use(express.json())
app.use(cors())

/* EXERCISE 01
        Create a new zero API (or using a template) and develop a 
        Get method test endpoint on Path “/test” that returns a 
        generic message warning that the API is functional:
*/
app.get('/test', (req: Request, res: Response) => {
    res.status(201).send("This API  is functional")
})


/* EXERCISE 02
        Create a file called Data.Ts that exports a product array. 
        Each product will be represented by an object 
        with properties: ID (string), name (string) and price (number). 
        Manually the array with at least 3 products:

        ---> On "data.ts"
*/


/* EXERCISE 03
        Develop an endpoint that creates a new product 
        and returns to the updated product list. The product ID must be 
        automatically generated by the API.
*/
app.post('/newProduct', (req: Request, res: Response) => {
    try {
        const {newProduct, newPrice} = req.body

        const newObject = { 
            id: generateId(),
            name: newProduct,
            price: newPrice

        }
        const addNewObject = products.push(newObject)
        res.status(201).send(products)
        
    } catch (error: any) {
        throw new Error("Something was wrong...")
    }
})

/* EXERCISE 04
        Create an endpoint that returns all products.
*/
app.get('/AllProducts', (req: Request, res: Response) => {
    res.status(200).send(products)
})

/* EXERCISE 05
       Create an endpoint that edits the price of a 
       particular product and returns to the updated product list.
*/
app.post('/editPrice', (req: Request, res: Response) => {
    try {
        const productName = req.body.name
        const newPrice = req.body.price
        const productToChange:any = products.find(element => element.name === productName)

        if(!productName || !newPrice){
            throw new Error("Product name and the new price are required!")
        }

        productToChange.price = newPrice
        res.status(201).send(products)

        
    } catch (error:any) {
        throw new Error("Data not found!")
    }
})

/* EXERCISE 06
       Build an endpoint that deletes a particular 
       product and returns to the updated product list.
*/
app.delete('/deleteProduct', (req: Request, res: Response) => {
    try {   
        const id = req.query.id
        const itemToDelete:any = products.findIndex(element => element.id === id)
        if(!id){
            throw new Error("Please, type an Id!")
        }

        if (itemToDelete !== -1){
        const updatedProducts = products.splice(itemToDelete, 1)
        res.status(201).send(updatedProducts)
    }   
        
    } catch (error:any) {
        res.status(404).send("Data not found!")
    }
})

/* EXERCISE 07
       Refatore the Endpoint of Exercise 3 (Create Product) to implement 
       validation flows of the data received (`name` and` price`)

- Error if one or none of them are received
- Error if `name` is different from` string`
- Error if `price` is different from` Number`
- Error if `price` is equal to or less than` 0`
- Error if something unexpected happens
*/
const Errors: {[key:string]:{ status:number, message:string }} = {
    MISSING_DATA: {status:400, message: "Name and Price are required."},
    DATA_INCONSISTENCE_NAME: {status:400, message: "Name must not be a number."},
    DATA_INCONSISTENCE_PRICE: {status:400, message: "Price must be a number."},
    PRICE_INCONSISTENCE: {status:400, message: "Price must be a number above zero."},
    NOT_FOUND: {status:404, message: "Data not found."},
    UNEXPECTED: {status:500, message: "something unexpected happens."}
}
app.post('/exerciseRefatored', (req: Request, res: Response) => {
    try {
        const {newProduct, newPrice} = req.body
        

        if (!newProduct || !newPrice) {
            throw new Error(Errors.MISSING_DATA.message)
        }
        if (typeof newProduct !== "string") {
            throw new Error(Errors.DATA_INCONSISTENCE_NAME.message)
        }
        if(typeof newPrice !== "number") {
            throw new Error(Errors.DATA_INCONSISTENCE_PRICE.message)
        }
        if(newPrice <= 0) {
            throw new Error(Errors.PRICE_INCONSISTENCE.message)
        }

        const newObject = { 
            id: generateId(),
            name: newProduct,
            price: newPrice

        }
        const addNewObject = products.push(newObject)
        res.status(201).send(products)
        
    } catch (error: any) {
       switch (error.message) {
        case Errors.MISSING_DATA.message:
            res.status(Errors.MISSING_DATA.status).send(Errors.MISSING_DATA.message)
            break;
        case Errors.DATA_INCONSISTENCE_NAME.message:
            res.status(Errors.DATA_INCONSISTENCE_NAME.status).send(Errors.DATA_INCONSISTENCE_NAME.message)
            break;
        case Errors.DATA_INCONSISTENCE_PRICE.message:
            res.status(Errors.DATA_INCONSISTENCE_PRICE.status).send(Errors.DATA_INCONSISTENCE_PRICE.message)
            break;
        case Errors.PRICE_INCONSISTENCE.message:
                res.status(Errors.PRICE_INCONSISTENCE.status).send(Errors.PRICE_INCONSISTENCE.message)
                break;    
        default:
            res.status(Errors.UNEXPECTED.status).send(Errors.UNEXPECTED.message)
            break;
       }
    }
})


/* EXERCISE 08
     Refactor the endpoint from exercise 5 (edit product) so that validation flows for received data (`price`) are implemented

- error if `price` is not received
- error if `price` is different from `number`
- error if `price` is equal to or less than `0`
- error if the product to be edited is not found
- error if something unexpected happens
*/
app.post('/editPriceRefactored', (req: Request, res: Response) => {
    try {
        const {productName, newPrice} = req.body
        
        const productToChange = products.find(element => element.name === productName)

        if(!productName || !newPrice){
            throw new Error(Errors.MISSING_DATA.message)
        }
        if (typeof newPrice !== "number") {
            throw new Error(Errors.DATA_INCONSISTENCE_PRICE.message)
        }
        if (newPrice <= 0) {
            throw new Error(Errors.PRICE_INCONSISTENCE.message)
        }
        if (!productToChange) {
            throw new Error(Errors.NOT_FOUND.message)
        }
        productToChange.price = newPrice
        res.status(201).send(products)

        
    } catch (error:any) {
        switch (error.message) {
            case Errors.MISSING_DATA.message:
                res.status(Errors.MISSING_DATA.status).send(Errors.MISSING_DATA.message)
                break;
            case Errors.DATA_INCONSISTENCE_PRICE.message:
                res.status(Errors.DATA_INCONSISTENCE_PRICE.status).send(Errors.DATA_INCONSISTENCE_PRICE.message)
                break;
            case Errors.PRICE_INCONSISTENCE.message:
                    res.status(Errors.PRICE_INCONSISTENCE.status).send(Errors.PRICE_INCONSISTENCE.message)
                    break;    
            case Errors.DATA_INCONSISTENCE_NAME.message:
                    res.status(Errors.NOT_FOUND.status).send(Errors.NOT_FOUND.message)
                    break;        
            default:
                res.status(Errors.UNEXPECTED.status).send(Errors.UNEXPECTED.message)
                break;
           }
    }
})

/* EXERCISE 09
     Refactor the endpoint from exercise 6 (delete product) so that validation flows for received data are implemented:

- error if the chosen product is not found
- error if something unexpected happens.
*/
app.delete('/deleteProductRefatored', (req: Request, res: Response) => {
    try {   
        const id = req.query.id
        const itemToDelete:any = products.findIndex(element => element.id === id)
        
        if(!id){
            throw new Error(Errors.MISSING_DATA.message)
        }        
        if( id !== itemToDelete){
            throw new Error(Errors.NOT_FOUND.message)
        }

        if (itemToDelete !== -1){
        const updatedProducts = products.splice(itemToDelete, 1)
        res.status(201).send(updatedProducts)
    }   
        
    } catch (error:any) {
        switch (error.message) {
            case Errors.MISSING_DATA.message:
                res.status(Errors.MISSING_DATA.status).send(Errors.MISSING_DATA.message)
                break;
            case Errors.NOT_FOUND.message:
                res.status(Errors.NOT_FOUND.status).send(Errors.NOT_FOUND.message)
                break;
            default:
                res.status(Errors.UNEXPECTED.status).send(Errors.UNEXPECTED.message)
                break;
           }
    }
})

/* EXERCISE 10
    Implement the following logic in the exercise 4 endpoint:

- the endpoint returns all products by default, but if a valid `“search”` query is received, the search result by product name is returned
     - for the query to be valid, it must not be `undefined`
*/
app.get('/searchProduct', (req: Request, res: Response) => {
    try {
        const {productName} = req.query
        const selectedProduct = products.find(product => product.name === productName)

        if(productName !== undefined){
            res.status(200).send(selectedProduct)
        }
        else {
            res.status(200).send(products)
        }
        
    } catch (error:any) {
        res.status(404).send("Something is not right :(")
    }
    
})



app.listen(3003, () => {
    console.log("Server is flying!")
} )